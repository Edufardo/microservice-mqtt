import { ConflictException, Inject, Injectable } from '@nestjs/common';
import { Model } from 'mongoose';
import { agvsSchema, IAgv } from '../models-mongo/agv.model';
import { MongoDbService } from '../mongo-db/mongo-db.service';
import { WS_AGVS } from '../websocket/constants/websocketEvents';
import { AgvConfig } from './agv-config';
import { AGV_PATTERNS } from './agv.patterns';
import { AgvNetworkDto } from './dto/agvNetwork.dto';
import { EditAgvNetworkDto } from './dto/editAgvNetwork.dto';

@Injectable()
export class AgvsService {
    
  private AgvModel: Model<IAgv>;

  constructor(
    @Inject('CONFIG_OPTIONS') private options: AgvConfig,
    private readonly mongoDb: MongoDbService,
  ){ 
    this.AgvModel = this.mongoDb
    .getConnection()
    .model<IAgv>('Agvs', agvsSchema, 'agvs');    
  }

  // Find and return an agv by Id
  async findAgv(agvId: string): Promise<IAgv> {
    const agv = await this.AgvModel.findOne({ id: agvId }).sort({ agvId: "asc"});
    return agv;
  }

  async createAgv(newAgv: AgvNetworkDto): Promise<IAgv> {
    const { id, ip, active } = newAgv;
    
    const agvExists: IAgv = await this.findAgv(id);
    if (agvExists) {
      console.log("[createAgv] Agv already exists.");
      throw new ConflictException('Agv already exists.');
    }
    
    const agv = new this.AgvModel({
      id,
      ip,
      active
    });

    try {
      await agv.save();

      console.log("[createAgv] Created new agv: ", agv);
      // this.notifyWebsockets();
      return agv;
    } catch (error) {
        console.log("[createAgv] ", error);
        throw new Error(error);
    }
  }
    
  async updateAgv(agvId: string, newAgv: EditAgvNetworkDto): Promise<IAgv> {
    const agv: IAgv = await this.findAgv(agvId);
    if (agv) {
 
      await agv.updateOne(
          {
            id: newAgv.id,
            ip: newAgv.ip,
            active: newAgv.active
          }
      );

      console.log('[updateAgv] Agv ' + agvId + ' updated: ');
      // this.notifyWebsockets();

      return agv;
    } else {
      console.log('[updateAgv] Agv ' + agvId + ' not found.');
      throw new ConflictException('[updateAgv] Agv not found.');
    }
  }

  async deleteAgv(agvId: string) {
      const agv: IAgv = await this.findAgv(agvId);
      if (agv) {
        await agv.delete();
        console.log('[deleteAgv] Agv ' + agvId + ' deleted.');
        // this.notifyWebsockets();
        return agv;
      } else {
        console.log('[deleteAgv] Agv ' + agvId + ' not found.');
        throw new ConflictException('Agv not found.');
      }
  }

  async changeAgvState(agvId: string): Promise<IAgv> {
    const agv: IAgv = await this.findAgv(agvId);
    console.log(agv)
    if (agv) {
      agv.active = !agv.active
      console.log('Estado cambiado: ', agv.active);
      await agv.updateOne({
        active: agv.active
      });
      console.log('[updateAgv] Agv ' + agvId + ' updated: ');
      // this.notifyWebsockets();
      return agv;
    } else {
      console.log('[updateAgv] Agv ' + agvId + ' not found.');
      throw new ConflictException('[updateAgv] Agv not found.');
    }
  }

  async fetchAllAgvs(): Promise<AgvNetworkDto[]> {
    try {
      let agvs = await this.AgvModel.find();
      return agvs as AgvNetworkDto[];
    } catch (error) {
      console.log("[fetchAllAgvs] ", error);
    }
  }

}
