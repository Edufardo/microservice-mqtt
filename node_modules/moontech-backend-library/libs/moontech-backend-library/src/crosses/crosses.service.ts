
import { ConflictException, Inject, Injectable, Optional } from "@nestjs/common";
import { Model } from "mongoose";
import { MicroserviceConnectionService } from "../microservice-connection/microservice-connection.service";
import { ICross, crossSchema } from "../models-mongo/cross.model";
import { MongoDbService } from "../mongo-db/mongo-db.service";
import { WS_CROSSES } from "../websocket/constants/websocketEvents";
import { WebsocketGateway } from "../websocket/websocket.gateway";
import { CrossesConfig } from "./crosses-config";
import { CROSSES_PATTERNS } from "./crosses.patterns";
import { Cross } from "./dto/crosses.dto";

@Injectable()
export class CrossesService {
  
  private CrossModel: Model<ICross>;

  constructor(
    private readonly mongoDb: MongoDbService
  ) {

    this.CrossModel = this.mongoDb
      .getConnection()
      .model<ICross>('Crosses', crossSchema, 'crosses');
  }
  
  async findCross(crossId: string):Promise<ICross>{
    return await this.CrossModel.findOne({ crossId }) 
  }

  async fetchCrosses() {
    try{
        let crosses = await this.CrossModel.find().sort({ crossId: "asc"})
        return crosses as Cross[];
    } catch (error) {
      console.error("[fetchCrosses] ", error);
      throw new Error(error);
    }
  }

  async createCross(newCross: Cross){
    let { crossId, occupied, waiting, agvId, description, blockingTags, liberationTags, zone } = newCross
    
    let cross = new this.CrossModel({ 
      crossId, 
      occupied, 
      waiting, 
      agvId, 
      description, 
      blockingTags, 
      liberationTags,
      zone
    });

    let crossExist: ICross = await this.findCross(crossId)

    if(crossExist){
      console.error("[createCross] Cross already exists.");
      throw new ConflictException('Cross already exists.');
    }else {
        try{
            await cross.save();

            console.log('[createCross] Cross created: ', cross);    
            // this.notifyWebsockets();
      
            return cross;
        }catch (err){
          console.error("[createCross] ", err);
          throw new Error(err);
        }
    }
  }

  async updateCross(crossId: string, newCross:Cross){
    let cross: ICross = await this.findCross(crossId)
    if(cross){
 
      await cross.updateOne(
        {
          crossId: newCross.crossId, 
          occupied: newCross.occupied,
          waiting: newCross.waiting,
          agvId: newCross.agvId,
          description: newCross.description,
          blockingTags: newCross.blockingTags,
          liberationTags: newCross.liberationTags,
          zone: newCross.zone
        }
      );

      const crossUpdate = await this.findCross(newCross.crossId);
      
      console.log("[updateCross] Cross updated: ", crossUpdate);

      // this.notifyWebsockets();
      return crossUpdate;
    }else {
      console.error("[updateCross] Cross not found.");
      throw new ConflictException('Cross not found.');
    }
  }


  async freeCross(crossId: string){
    let cross: ICross = await this.findCross(crossId)
    if(cross){
 
      await cross.updateOne(
        {
          occupied: false,
          waiting: [],
        }
      );

      const crossUpdate = await this.findCross(crossId);
      
      console.log("[freeCross] Cross updated: ", crossUpdate);

      // this.notifyWebsockets();
      return crossUpdate;
    }else {
      console.error("[freeCross] Cross not found.");
      throw new ConflictException('Cross not found.');
    }
  }

  async deleteCross(crossId: string){
    let cross: ICross = await this.findCross(crossId)
    if(cross){
      await cross.delete();
      console.error("[deleteCross] Cross " + crossId + " deleted.");
      // this.notifyWebsockets();
      return cross;
    } else {
      console.error("[deleteCross] Cross not found.");
      throw new ConflictException('Cross not found.');
    }
  }

}
