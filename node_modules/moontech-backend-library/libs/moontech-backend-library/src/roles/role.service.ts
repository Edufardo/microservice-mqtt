import { ConflictException, forwardRef, Inject, Injectable } from '@nestjs/common';
import { Model } from 'mongoose';
import { PermissionDto } from '../permissions/dto/permission.dto';
import { IRole, roleSchema } from '../models-mongo/role.model';
import { MongoDbService } from '../mongo-db/mongo-db.service';
import { RoleDto } from './dto/role.dto';
import { PermissionService } from '../permissions/permissions.service';
import { IPermission } from '../models-mongo/permission.model';
import { WebsocketGateway } from '../websocket/websocket.gateway';
import { WS_ROLES } from '../websocket/constants/websocketEvents';
import { UsersService } from '../users/users.service';

@Injectable()
export class RoleService {


    private RoleModel: Model<IRole>;
  
    constructor(
      private readonly mongoDb: MongoDbService,
      private readonly permissionService: PermissionService,
      @Inject(forwardRef(() => UsersService))
      private usersService: UsersService,
      private readonly websocketService: WebsocketGateway
    ) { 
      
        this.RoleModel = this.mongoDb
          .getConnection()
          .model<IRole>("Role", roleSchema, "roles");
      
    }

    async populate(){

        const permissions: IPermission[] = await this.permissionService.fetchAllPermissions();

        const roles: RoleDto[] = [
            {
                name: "superadmin",
                permissions: []
            },
            {
                name: "admin",
                permissions: [
                    new PermissionDto('CREATE'),
                    new PermissionDto('READ'),
                    new PermissionDto('UPDATE'),
                    new PermissionDto('DELETE'),
                ]
            },
            {
                name: "operator",
                permissions: [
                    new PermissionDto('CREATE'),
                    new PermissionDto('READ'),
                ]
            }
        ];
         
        for (const r of roles) {
            
            const role = await this.findRole(r.name);
            if (!role) {
                await this.createRole(r);
            }
    
        }
    }

    async getRoles(){
        try {
            const roles = await this.RoleModel.find({ name: { $ne: "superadmin" } }).populate('permissions');
            console.log("[getRoles] Roles: ", roles);
            return roles as RoleDto[];
          } catch (error) {
            console.log("[getRoles] ", error);
            throw new Error(error);
          }
    }


    // CREATE NEW ROLE into DB if does not exists already.
    async createRole(role: RoleDto): Promise<RoleDto> {

        const roleExists = await this.findRole(role.name)
        if(roleExists){
            console.log("[createRole] Role " + role.name + " already exists");
            throw new ConflictException(role.name + " already exists");
        }

        const newRole = new this.RoleModel({
            name: role.name,
            permissions: []
        });

        for (const p of role.permissions) {
            const permission = await this.permissionService.findPermission(p.permissionName);
            if(!permission){
                console.log("[createRole] " + permission.permissionName + " not found");
                throw new ConflictException(permission.permissionName + " not found");
            }else{
                newRole.permissions.push(permission._id);
            }
        }

        try {
            await newRole.save();

            console.log("[createRole] New role created: ", newRole);
      
            this.notifyWebsockets();

            return newRole;
        } catch (error) {
            console.log("[createRole] ", error);
            throw new Error(error);
        }
    }

    // DELETE existing ROLE
    async deleteRole(roleName: string) {
        
        try {
            const role = await this.RoleModel.findOne({ name: roleName });
            if (role) {

                const hasUsers: boolean = await this.usersService.roleHasUsers(role.name);
                if(hasUsers){
                    console.log('[deleteRole] Role ' + roleName + ' has users.');
                    throw new ConflictException('Role ' + roleName + ' has users.');
                }
                
                role.delete();
                console.log('[deleteRole] Role ' + roleName + ' deleted.');
                this.notifyWebsockets();
            } else {
                console.log('[deleteRole] Role ' + roleName + ' not found.');
                throw new ConflictException('Role ' + roleName + ' not found.');
            }
            return role;
        } catch (error) {
           console.log("[deleteRole] ", error);
           throw new Error(error);
        }
    }

    // UPDATE existing ROLE
    async updateRole(oldRoleName: string, newRole: RoleDto) {
        const existsRole = await this.findRole(oldRoleName);
        if (existsRole){
            try {

                for (const p of newRole.permissions) {
                    const permission = await this.permissionService.findPermission(p.permissionName);
                    if(!permission){
                        console.log("[updateRole] " + permission.permissionName + " not found");
                        throw new ConflictException(permission.permissionName + " not found");
                    }
                }

                await existsRole.updateOne(
                    {
                        name: newRole.name,
                        permissions: newRole.permissions
                    }
                );
                
                const roleUpdated = await this.findRole(newRole.name);
            
                console.log("[updateRole] Role updated: ", roleUpdated);

                this.notifyWebsockets();

                return roleUpdated;

            } catch (error) {
                console.log("[updateRole] ", error);
                throw new Error(error);
            }
        } else {
            console.log("[updateRole] Role " + oldRoleName + " not found.");
            throw new ConflictException('Role ' + oldRoleName + ' not found.');
        }
    }

    async findRole(role: string) {
        
        try {
          const roleFound: IRole = await this.RoleModel.findOne({ name: role });
          return roleFound;
        } catch (error) {
          console.log("[findRole] ", error);
        }
        return null;
    }

    // WEBSOCKET: Notify change to all clients
    async notifyWebsockets(){

      try {
        let roles = await this.getRoles();
        this.websocketService.sendMessageBroadcast(WS_ROLES, roles);
      } catch (err) {
        console.error('[Websocket] Emit error - buffer free');
        console.error(err);
      }

    }

}
