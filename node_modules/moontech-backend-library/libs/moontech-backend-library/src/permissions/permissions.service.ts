import { ConflictException, Inject, Injectable } from '@nestjs/common';
import { MongoDbConfig } from '../mongo-db/mongo-db-config';
import { MongoDbService } from '../mongo-db/mongo-db.service';
import { PermissionDto } from './dto/permission.dto';
import { IPermission, permissionSchema } from '../models-mongo/permission.model';
import { Model } from 'mongoose';
import { WebsocketGateway } from '../websocket/websocket.gateway';
import { WS_PERMISSIONS } from '../websocket/constants/websocketEvents';

@Injectable()
export class PermissionService {
  
  private PermissionModel: Model<IPermission>;
  
  constructor(
    private readonly mongoDb: MongoDbService,
    private websocketService: WebsocketGateway
  ) {
    this.PermissionModel = this.mongoDb
      .getConnection()
      .model<IPermission>('Permission', permissionSchema, 'permissions');
  }

  async populate() {
    
    const permissions: string[] = [
      "CREATE",
      "UPDATE",
      "READ",
      "DELETE",
      "CREATE_USER",
      "READ_USER",
      "UPDATE_USER",
      "DELETE_USER",
      "CREATE_ROLE",
      "READ_ROLE",
      "UPDATE_ROLE",
      "DELETE_ROLE",
      "CREATE_PERMISSION",
      "READ_PERMISSION",
      "UPDATE_PERMISSION",
      "DELETE_PERMISSION"
    ];
    
    for (const p of permissions) {
      
      const permission = await this.findPermission(p);
      if (!permission) {
      
        const newPermission = new this.PermissionModel({
          permissionName: p,
        });
        await this.createNewPermission(newPermission);

      }
 
    }

  }

  // CREATE NEW permission
  async createNewPermission(newPermission: PermissionDto): Promise<PermissionDto> {

    const permission = new this.PermissionModel({
      permissionName: newPermission.permissionName,
    });

    try {
      await permission.save();
      
      console.log("[createNewPermission] Create new permission: ", permission);
      
      return permission;
    } catch (error) {
      // Control Duplicated Values( Error code 11000)
      if ((error.code = 11000)) {
        for (const [key, value] of Object.entries(error?.keyValue)) {
          throw new ConflictException("[createNewPermission] "+key + ' already exists (' + value + ')');
        }
      } else {
        console.log("[createNewPermission] ", error);
        throw new Error(error);
      }
    }
  }

  // DELETE existing ROLE

  async deletePermission(permissionName: string) {

    try {
      const permission = await this.PermissionModel.findOne({ permissionName });
      if (permission) {
        permission.delete();
        console.log('[deletePermission] Role ' + permission + ' deleted.');
      } else {
        console.log('[deletePermission] Role ' + permissionName + ' not found.');
      }
    } catch (error) {
      console.log("[deletePermission] ",error);
      throw new Error(error);
    }
  }

  // UPDATE existing Permission
  async updatePermission(permissionName: string, newPermission: PermissionDto) {
    const existingPermission = await this.findPermission(permissionName);
    //console.log(existingRole);
    if (existingPermission)
      try {
        Object.assign(existingPermission, newPermission);
        await existingPermission.save();
        console.log('[updatePermission] Role ' + permissionName + ' updated to ' + newPermission.permissionName);
      } catch (error) {
        console.log("[updatePermission] ", error);
        throw new Error(error);
      }
    else {
      console.log("[updatePermission] Role " + permissionName + " not found.");
      throw new ConflictException('Role ' + permissionName + ' not found.');
    }
  }

  // FIND a single role and return its object

  async findPermission(permissionName: string) {
    
    try {
      const permission = await this.PermissionModel.findOne({ permissionName });
      return permission;
    } catch (error) {
      console.log(error);
    }
    return null;
  }


  // FIND all roles and return a array of objects
  async fetchAllPermissions() {
    try {
      const permissions = await this.PermissionModel.find();
      return permissions;
    } catch (error) {
      console.log("[fetchAllPermissions] ", error);
    }
    return null;
  }


  // WEBSOCKET: Notify change to all clients
  async notifyWebsockets(){

    try {
      let permissions = await this.fetchAllPermissions();
      this.websocketService.sendMessageBroadcast(WS_PERMISSIONS, permissions);
    } catch (err) {
      console.error('[Websocket] Emit error - buffer free');
      console.error(err);
    }

  }
}
