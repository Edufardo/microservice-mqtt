import { Injectable, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { UsersService } from '../users/users.service';
import { AuthCredentialsDto } from './dto/auth-credentials.dto';
import { Token } from './dto/token.dto';
import { JwtPayload } from './interfaces/jwt-payload.interface';

@Injectable()
export class AuthService {
  constructor(
    private readonly usersService: UsersService,
    private jwtService: JwtService,
  ) {
    
  } // private readonly sharedDbService: SharedDbService, // Instantiate necessary modules

  // Sign In an existing user and return a valid token id if valid.
  async logIn(
    authCredentialsDto: AuthCredentialsDto,
  ): Promise<{ accessToken: string }> {
    //Retrieve userCode is credentials are OK
    const userCode = await this.validateUserPassword(authCredentialsDto);

    if (!userCode) {
      throw new UnauthorizedException('Invalid credentials.');
    }

    // We create the payload for the JWT token
    const payload: JwtPayload = { userCode };
    const accessToken: string = this.jwtService.sign(payload);

    return new Token(accessToken, 'jwt', 'WIP');
  }

  // Validate User Password - if password is valid, we return the userCode, otherwise null
  async validateUserPassword(authCredentialsDto: AuthCredentialsDto) {
    const { userCode, password } = authCredentialsDto;

    // Retrieve user from DB based on the userCode
    const user = await this.usersService.findUser(userCode);
    if (user) {
      const validPassword = await user.comparePassword(password);
      //console.log(validPassword);

      if (validPassword) {
        //console.log(user.userCode);
        return user.userCode;
      } else {
        return null;
      }
    } else {
      throw new UnauthorizedException('Invalid credentials.');
    }
  }

  async fetchUserData(userCode: string){
    const user = await this.usersService.fetchUserData(userCode);
    return user;
  }
}
