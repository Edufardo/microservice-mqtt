import { ConflictException, forwardRef, Inject, Injectable } from '@nestjs/common';
import { ObjectId } from 'mongodb';
import { Model } from 'mongoose';
import { IPermission } from '../models-mongo/permission.model';
import { IRole } from '../models-mongo/role.model';
import { IUser, userSchema } from '../models-mongo/user.model';
import { MongoDbService } from '../mongo-db/mongo-db.service';
import { PermissionDto } from '../permissions/dto/permission.dto';
import { RoleDto } from '../roles/dto/role.dto';
import { RoleService } from '../roles/role.service';
import { WS_USERS } from '../websocket/constants/websocketEvents';
import { WebsocketGateway } from '../websocket/websocket.gateway';
import { CreateUserDto } from './dto/createUser.dto';
import { EditUserDto } from './dto/editUser.dto';
import { UserDto } from './dto/user.dto';

@Injectable()
export class UsersService {

  private UserModel: Model<IUser>;

  constructor(
    private readonly mongoDb: MongoDbService,
    @Inject(forwardRef(() => RoleService))
    private roleService: RoleService,
    private readonly websocketService: WebsocketGateway
  ) { 
    this.UserModel = this.mongoDb
      .getConnection()
      .model<IUser>('User', userSchema, 'users');
  }

  public async populate() {
    
    const users: UserDto[] = [
      {
        "userCode": "superadmin",
        "password": "123456789Abc!",
        "email": "superadmin@moontech.com",
        "role": new RoleDto("superadmin", [])
      },
      {
        "userCode": "admin",
        "password": "123456789Abc!",
        "email": "admin@moontech.com",
        "role": new RoleDto("admin", [
          new PermissionDto("CREATE"),
          new PermissionDto("READ"),
          new PermissionDto("UPDATE"),
          new PermissionDto("DELETE")
        ])
      }
    ];
   
    for (const u of users) {
      
      const user = await this.findUser(u.userCode);
      if (!user) {
        await this.createUser(u);
      }
 
    }
  }

  // Inserts user into DB if does not exists already.
  // Deletes field password from response

  async createUser(newUser: CreateUserDto): Promise<UserDto> {
    
    // Check if user already exists
    const user: IUser = await this.findUser(newUser.userCode);
    // Checkif provided role exists in available roles.
    if (user) {
      console.log("[createUser] User already exists.");
      throw new ConflictException('User already exists.');
    }

    const roleExists: IRole = await this.roleService.findRole(newUser.role.name);
    if(!roleExists){
      console.log("[createUser] Role does not exist.");
      throw new ConflictException('Role does not exist.');
    }

    // Insert into db if user does not exist already
    try {

      // Create a User Document
      const user = new this.UserModel({
        //id_or_operatorcode, // WIP - To be determined what to store here.
        userCode: newUser.userCode,
        password: newUser.password,
        email: newUser.email,
        role: roleExists._id
      });

      // Save the USER to DB
      await user.save();

      console.log("[createUser] New user created ", user);
      this.notifyWebsockets();

      user.password = undefined;
      return user;
    } catch (error) {
      // Control Duplicated Values( Error code 11000)
      console.log(error);
      if ((error.code = 11000)) {
        if (error.keyValue) {
          for (const [key, value] of Object.entries(error?.keyValue)) {
            throw new ConflictException("[createUser] " + key + ' already exists (' + value + ')',
            );
          }
        }
      } else {
        console.log("[createUser] ", error);
        throw new Error(error);
      }
    }
    
  }

  // Delete existing user
  async deleteUser(userCode: string) {
    const user: IUser = await this.findUser(userCode);
    if (user) {
      await user.delete();
      console.log('[deleteUser] User ' + userCode + ' deleted.');
      this.notifyWebsockets();
      return user;
    } else {
      console.log('[deleteUser] User not found.');
      throw new ConflictException('User not found.');
    }
  }

  // TODO: Validate and check
  // Update existing user WIP - usercCode should be unique at DB level?
  async updateUser(userCode: string, newUser: EditUserDto): Promise<IUser> {
    const user = await this.findUser(userCode);
    if (user) {

      // If field password, check that matches with DB
      if (newUser.password) {
        let res: boolean = await user.comparePassword(newUser.password);
        if (!res) {
          console.log('[updateUser] Incorrect password.');
          throw new ConflictException('Incorrect password.');
        }
      }

      const roleExists: IRole = await this.roleService.findRole(newUser.role.name);
      if(!roleExists){
        console.log("[updateUser] Role does not exist.");
        throw new ConflictException('Role does not exist.');
      }
      // Assign new values to updated fields WIP

      try {

        await user.updateOne(
          {
            userCode: newUser.userCode,
            password: newUser.password,
            email: newUser.email,
            role: roleExists._id
          }
        );
  
        console.log('[updateUser] User ' + userCode + ' updated.');
        this.notifyWebsockets();
        return user;
      } catch (error) {
        console.error("[updateUser] ", error);
        throw new Error(error);
      }
    } else {
      console.log('[updateUser] User not found');
      throw new ConflictException('User not found.');
    }
  }

  // Find and return a user by userCode
  async findUser(userCode: string): Promise<IUser> {
    const user = await this.UserModel.findOne({ userCode: userCode.toLowerCase() });
    return user;
  }

  // FIND all users and return a array of objects
  // Deletes field password from response

  async fetchAllUsers(): Promise<UserDto[]> {
 
    try {
      let users = await this.UserModel.find({ userCode: { $ne: "superadmin" } }).populate('role');

      // Manual populate
      for (const u of users) {
        const role = await this.roleService.findRole(u.role.name)
        u.role = await role.populate('permissions').execPopulate();
      }

      users.forEach((user: IUser) => {
        user.password = undefined;
      });
      return users as UserDto[];
    } catch (error) {
      console.log(error);
    }
  }

  async roleHasUsers(name: string){
    const users = await this.UserModel.aggregate([
      {
        $lookup: {
          from: "roles",
          localField: "role",
          foreignField: "_id",
          as: "role"
        }, 
      },
      {
        $match: {
          "role.name": name
        }
      }
    ]);
    return users.length > 0
  }

  async fetchUserData(userCode: string){
    const user = await this.UserModel.findOne({ userCode }).populate('role');
    const role = await this.roleService.findRole(user.role.name)
    user.role = await role.populate('permissions').execPopulate();
    return user;
  }


  // WEBSOCKET: Notify change to all clients
  async notifyWebsockets(){

    try {
      let users = await this.fetchAllUsers();
      this.websocketService.sendMessageBroadcast(WS_USERS, users);
    } catch (err) {
      console.error('[Websocket] Emit error - buffer free');
      console.error(err);
    }

  }
  
}
