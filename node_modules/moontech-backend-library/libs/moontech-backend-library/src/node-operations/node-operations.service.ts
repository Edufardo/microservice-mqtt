import {
  ConflictException,
  Injectable,
  NotFoundException,
} from '@nestjs/common';
import {
  AttributeIds,
  ClientSession,
  coerceNodeId,
  DataType,
  DataValue,
  NodeClass,
  NodeId,
  StatusCodes,
} from 'node-opcua-client';
import { PlcVariable } from './models/PlcVariable';
import { INVALID_SESSION } from './node-operations.constants';

@Injectable()
export class NodeOperationsService {
  constructor() {}

  /**
   * Check if client session exists
   */
  async check_session(session: ClientSession): Promise<boolean> {
    return session != null;
  }

  /**
   * This function reads multiple variables defined by its PLC route
   * @param nodeId -> Variable returns all sub-variables
   * @param session -> Assumes session exists
   */
  async getMultiplePlcVariablesValueByNodeId(
    session: ClientSession,
    nodeId: string[],
  ): Promise<any> {
    // Check if session is open
    if (!(await this.check_session(session))) {
      console.log(`${INVALID_SESSION} ${session}`);
    } else {
      try {
        let res = await Promise.all(
          nodeId.map(async (element) => {
            return await this.getPlcVariableValueByNodeId(session, element);
          }),
        );
        // Sort alphabetically
        return res.sort((a: any, b: any) => {
          if (a.name > b.name) {
            return 1;
          }
          if (a.name < b.name) {
            return -1;
          }
          // a must be equal to b
          return 0;
        });
      } catch (error) {
        throw new ConflictException(`[Error] ${error}`);
      }
    }
  }

  /**
   * This function reads a variable if nodeId exists, else throws exception
   * @param nodeId -> Variable returns all sub-variables
   * @param session -> Assumes session exists
   */
  async getPlcVariableValueByNodeId(
    session: ClientSession,
    nodeId: string,
  ): Promise<PlcVariable> {
    // Check if session is open
    if (!(await this.check_session(session))) {
      console.log('Invalid session');
    } else {
      try {
        // console.log(`nodeId: ${nodeId}`);
        const readValue = {
          nodeId: nodeId,
          attributeId: AttributeIds.Value,
        };
        const readName = {
          nodeId: nodeId,
          attributeId: AttributeIds.DisplayName,
        };
        const readDataType = {
          nodeId: nodeId,
          attributeId: AttributeIds.DataType,
        };

        const dataValue: DataValue[] = await session.read([
          readValue,
          readName,
          readDataType,
        ]);

        // console.log(`Datavalue: ${dataValue}`);

        // console.log(dataValue[0].value.value);

        // Find by regExp [whathever] text=[name] [whatever]
        let parsedName = dataValue[1].value.value
          .toString()
          .match(/text=.*/)[0]
          .split('=')[1]
          .split(' ')[0];
        let parsedDataType = dataValue[2].value.value.value;
        // console.log({ variableName: parsedName, value: dataValue.value.value, type: DataType[parsedDataType] })
        return new PlcVariable(
          parsedName,
          dataValue[0].value.value,
          DataType[parsedDataType],
        );
      } catch (error) {
        // If node does not exist
        throw new NotFoundException(`[Error] This nodeId does not exist`);
      }
    }
  }

  /**
   * Returns true if written correctly, else throws exception
   *
   * @param nodeId
   * @param nodeValue
   *
   */

  async setPlcVariableValueByNodeId(
    session: ClientSession,
    nodeId: string,
    nodeValue: any,
  ): Promise<boolean> {
    // Check if session is open
    if (!(await this.check_session(session))) {
      console.log('Invalid session');
    } else {
      // Write
      try {
        // Reads type of PLC nodeId and assigns same type to the value to be written
        const nodeIdClass: NodeId = coerceNodeId(nodeId);
        // // Get the NodeId Object
        const dataType: DataType = await session.getBuiltInDataType(
          nodeIdClass,
        );
        // console.log(dataType);

        const nodeToWrite = {
          nodeId: nodeId,
          attributeId: AttributeIds.Value,
          value: {
            value: {
              dataType: dataType,
              //dataType: DataType[dataType],
              value: nodeValue,
            },
          },
        };

        //Try to write value
        const statusCode = await session.write(nodeToWrite);
        console.log(statusCode);
        return statusCode === StatusCodes.Good;
      } catch (error) {
        throw new ConflictException(`[Error] ${error}`);
      }
    }
  }

  /**
   * Browse a root Variable or Object and list its childs
   * @param nodeId nodeId route. i.e. ns=3;s="Ordenes_AGV"."rt"
   * This will list all subnodes of rt in this
   */
  async browseByNodeId(session: ClientSession, nodeId: string): Promise<any> {
    // Check if session is open
    if (!(await this.check_session(session))) {
      console.log('Invalid session');
    } else {
      // Browse
      try {
        let browseResultObject = await session.browse({
          nodeId,
          nodeClassMask: NodeClass.Object, // we only want sub node that are Objects
          // browseDirection: 0
        });
        // console.log('BrowseResultObject = ', browseResultObject.toString());

        let browseResultVariable = await session.browse({
          nodeId,
          nodeClassMask: NodeClass.Variable, // we only want sub node that are Variables,
        });
        // console.log('BrowseResultVariable = ', browseResultVariable.toString());
        return {
          // variables: browseResultVariable,
          variables: browseResultVariable.references.map((item) => {
            return item.nodeId;
          }),
          // objects: browseResultObject.references.map((item) => {
          //   return item.nodeId;
          // }),
          objects: browseResultObject,
        };
      } catch (error) {
        throw new ConflictException(`[Error] ${error}`);
      }
    }
  }
}
