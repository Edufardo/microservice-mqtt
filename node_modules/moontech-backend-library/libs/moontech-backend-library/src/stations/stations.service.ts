import { ConflictException, Injectable } from '@nestjs/common';
import { Model } from 'mongoose';
import { STATUS } from '../common/status';
import { IStation, stationSchema } from '../models-mongo/station.model';
import { MongoDbService } from '../mongo-db/mongo-db.service';
import { WS_STATIONS } from '../websocket/constants/websocketEvents';
import { WebsocketGateway } from '../websocket/websocket.gateway';
import { StationDto } from './dto/station.dto';

@Injectable()
export class StationsService {

  private StationModel: Model<IStation>;

  constructor(
    private readonly mongoDb: MongoDbService,
    private readonly websocketService: WebsocketGateway
  ) { 
    this.StationModel = this.mongoDb
      .getConnection()
      .model<IStation>('Station', stationSchema, 'stations');
  }

  public async populate(){

    const stations: StationDto[] = [
      {
        name: 'Station-1',
        coords: '100-110-120',
        status: STATUS.FREE
      },
      {
        name: 'Station-2',
        coords: '100-130-140',
        status: STATUS.FREE
      },
      {
        name: 'Station-3',
        coords: '100-150-160',
        status: STATUS.FREE
      },
      {
        name: 'Station-4',
        coords: '100-160-170',
        status: STATUS.FREE
      }
    ]

    for (const s of stations) {
      
      const station = await this.findStation(s.name);
      if(!station){
        await this.createStation(s);
      }

    }

  }


  public async getStations(){
    try {
      let stations = await this.StationModel.find();
      console.log("[getStations] Stations: ", stations);
      return stations as StationDto[];
    } catch (error) {
      console.log("[getStations] ", error);
      throw new Error(error);
    }
  }

  async getStationsByStatus(status: string){
    
    const existsStatus: STATUS = status as STATUS;

    if(existsStatus){
      const stations = await this.StationModel.find({ status: existsStatus })
                          .sort({name: -1});
      return stations as StationDto[];
    }else{
      console.error("[getStationsByStatus] Status incorrect: " + status);
      throw new ConflictException("Status incorrect: " + status);
    }

  }

  public async createStation(station: StationDto){
      
      // Check if station already exists
      const existsStation: IStation = await this.findStation(station.name);
      
      if (existsStation) {
        console.log("[createStation] Station already exists");
        throw new ConflictException('Station already exists.');
      }
      
      const newStation = new this.StationModel({
          ...station
      });
      
      try {
        // Save to DB
        await newStation.save();
        
        console.log("[createStation] New station created: ", station);
  
        this.notifyWebsockets();

        return newStation;
      } catch (error) {
        console.error('[createStation] ', error);
        throw new Error(error);
      }
  }

  public async updateStation(station: StationDto){

      const stationOriginal = await this.findStation(station.name);
      if (stationOriginal) {
          
          await stationOriginal.updateOne(
              {
                  coords: station.coords,
                  status: station.status
              }
          );

          const stationUpdate = await this.findStation(station.name);
          
          console.log("[createStation] Station updated: ", station);

          this.notifyWebsockets();
          return stationUpdate;
      } else {
        console.log('[updateStation] Station not found.');
        throw new ConflictException('Station not found.');
      }
  }

  public async updateStationById(station: StationDto, id: string){

      const stationOriginal = await this.findById(id);
      if (stationOriginal) {
          
          await stationOriginal.updateOne(
              {
                  name: station.name,
                  coords: station.coords,
                  status: station.status
              }
          );

          console.log("[updateStationById] Station updated: ", station);
          
          this.notifyWebsockets();
          return stationOriginal;
      } else {
        console.error('[updateStationById] Station not found.');
        throw new ConflictException('Station not found.');
      }
  }

  public async deleteStation(name: string){
      const station: IStation = await this.findStation(name);
      if (station) {
        await station.delete();
        console.log("[deleteStation] Station deleted: ", station);
        this.notifyWebsockets();
        return station;
      } else {
        console.error('[deleteStation] Station not found.');
        throw new ConflictException('Station not found.');
      }
  }

  public async freeStation(name: string){
    const station: IStation = await this.findStation(name);
    if (station) {
      station.status = STATUS.FREE;
      await this.updateStation(station);
      console.log("[freeStation] Station has been freed: ", station);
      this.notifyWebsockets();
      return true;
    } else {
      console.error('[freeStation] Station not found.');
      return false;
    }
  }

  public async occupyStation(name: string){
    const station: IStation = await this.findStation(name);
    if (station) {
      station.status = STATUS.OCCUPIED;
      await this.updateStation(station);
      console.log("[occupyStation] Station has been occupied: ", station);
      this.notifyWebsockets();
      return true;
    } else {
      console.error('[occupyStation] Station not found.');
      return false;
    }
  }

  async findStation(name: string): Promise<IStation> {
      const station = await this.StationModel.findOne({ name });
      return station;
  }

  private async findById(id: string): Promise<IStation> {
      const station = await this.StationModel.findOne({ _id: id });
      return station;
  }


  // WEBSOCKET: Notify change to all clients
  async notifyWebsockets(){

    try {
      let stations = await this.getStations();
      this.websocketService.sendMessageBroadcast(WS_STATIONS, stations);
    } catch (err) {
      console.error('[Websocket] Emit error - buffer free');
      console.error(err);
    }

  }


    
}
