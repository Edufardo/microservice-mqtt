import { ConflictException, Inject, Injectable } from '@nestjs/common';
import { Model } from 'mongoose';
import { IOrder, orderHistoricSchema, orderSchema } from '../models-mongo/order.model';
import { IRole } from '../models-mongo/role.model';
import { MongoDbService } from '../mongo-db/mongo-db.service';
import { StationsService } from '../stations/stations.service';
import { WS_CONFIRMED_ORDERS, WS_CURRENT_ORDERS, WS_FINISHED_ORDERS, WS_HISTORIC_ORDERS, WS_PENDING_ORDERS } from '../websocket/constants/websocketEvents';
import { WebsocketGateway } from '../websocket/websocket.gateway';
import { OrderDto } from './dto/order.dto';
import { OrderConfig } from './order-config';

@Injectable()
export class OrdersService {

    private OrderModel: Model<IOrder>;
    private OrderHistoricModel: Model<IOrder>;
    private OrderFinishedModel: Model<IOrder>;

    private historic: boolean;
    private finished: boolean;

    constructor(
        @Inject('CONFIG_OPTIONS') private options: OrderConfig, 
        private readonly mongoDb: MongoDbService,
        private readonly stationService: StationsService,
        private readonly websocketService: WebsocketGateway
    ){

        if(this.options){
            this.historic = this.options.historic;
            this.finished = this.options.finished;
        }else{
            this.historic = true;
            this.finished = true;
        }

        this.OrderModel = this.mongoDb
            .getConnection()
            .model<IOrder>('Order', orderSchema, 'orders');
        
        if(this.historic){
            this.OrderHistoricModel = this.mongoDb
                .getConnection()
                .model<IOrder>('Order', orderHistoricSchema, 'orders-historic');
        }

        if(this.finished){
            this.OrderFinishedModel = this.mongoDb
                .getConnection()
                .model<IOrder>('Order', orderSchema, 'orders-finished');
        }

    }

    async fetchAllOrders(){
        const orders = await this.OrderModel.find()
            .populate('origin')
            .populate('destination');
        return orders;
    }

    async getPendingOrders(){
        const orders = await this.OrderModel
            .find({ confirmAt: null, agvId: null, finishAt: null })
            .populate('origin')
            .populate('destination')
            .sort({ priority: -1, insertedAt: 1 });;
        return orders;
    }

    async getConfirmedOrders(){
        const orders = await this.OrderModel
            .find({ confirmAt: {$ne: null}, agvId: null, finishAt: null })
            .populate('origin')
            .populate('destination')
            .sort({ priority: -1, confirmAt: 1, insertedAt: 1 });
        return orders;
    }

    async getCurrentOrders(){
        const orders = await this.OrderModel
            .find({ confirmAt: {$ne: null}, agvId: {$ne: null}, finishAt: null })
            .populate('origin')
            .populate('destination')
            .sort({ priority: -1, confirmAt: 1, insertedAt: 1 });;
        return orders;
    }

    async getFinishedOrders(){
    
        if(this.finished){       
            const orders = await this.OrderFinishedModel
                .find({ finishAt: {$ne: null} })
                .populate('origin')
                .populate('destination')
                .sort({ finishAt: 1 });
            return orders;
        }else{
            return [];
        }
    }

    async getOrdersByType(type: string){
        const orders = await this.OrderModel
            .find({ type })
            .populate('origin')
            .populate('destination')
            .sort({ insertedAt: 1 });
        return orders;
    }

    async fetchHistoricOrders(){
        if(this.historic){
            const orders = await this.OrderModel.aggregate([
                {
                  $lookup: {
                    from: "orders-historic",
                    localField: "id",
                    foreignField: "id",
                    as: "versions"
                  }
                },
                {
                    $match: {
                        versions: {
                            $ne: []
                        }
                    }
                  }
              ])
    
            return orders;
        }else{
            return [];
        }
    }

    async createNewOrder(order: OrderDto){
        
        const orderExists = await this.findOrder(order.id)
        if(orderExists){
            console.log("[createNewOrder] Order " + order.id + " already exists");
            throw new ConflictException(order.id + " already exists");
        }

        const originStation = await this.stationService.findStation(order.origin.name);
        if(!originStation){
            console.log("[createNewOrder] Origin station " + order.origin.name + " not found.");
            throw new ConflictException(order.id + " not found.");
        }

        let destinationStation = null;
        if(order.destination.name){
            destinationStation = await this.stationService.findStation(order.destination.name);
            if(!destinationStation){
                console.log("[createNewOrder] Destination station " + order.destination.name + " not found.");
                throw new ConflictException(order.destination.name + " not found.");
            }
        }

        const newOrder = new this.OrderModel({
            ...order,
            origin: originStation,
            destination: destinationStation
        });

        try {
            await newOrder.save();

            this.newVersion(newOrder, 0);

            console.log("[createNewOrder] New order created: ", newOrder);
      
            this.notifyWebsockets();

            return newOrder;
        } catch (error) {
            console.log("[createNewOrder] ", error);
            throw new Error(error);
        }
    }

    async updateOrder(id: string, newOrder: OrderDto){
        const existsOrder = await this.findOrder(id);
        if (existsOrder){
            try {

                const originStation = await this.stationService.findStation(newOrder.origin.name);
                if(!originStation){
                    console.log("[updateOrder] Origin station " + newOrder.origin.name + " not found.");
                    throw new ConflictException(newOrder.origin.name + " not found.");
                }

                let destinationStation = null;
                if(newOrder.destination.name){
                    destinationStation = await this.stationService.findStation(newOrder.destination.name);
                    if(!destinationStation){
                        console.log("[updateOrder] Destination station " + newOrder.destination.name + " not found.");
                        throw new ConflictException(newOrder.destination.name + " not found.");
                    }
                }

                await existsOrder.updateOne(
                    {
                        type: newOrder.type,
                        description: newOrder.description,
                        insertedAt: newOrder.insertedAt,
                        confirmAt: newOrder.confirmAt,
                        finishAt: newOrder.finishAt,
                        trafficReadAt: newOrder.trafficReadAt,
                        trafficStartedAt: newOrder.trafficStartedAt,
                        trafficFinishedAt: newOrder.trafficFinishedAt,
                        manual: newOrder.manual,
                        agvId: newOrder.agvId,
                        priority: newOrder.priority,
                        origin: originStation,
                        destination: destinationStation,
                        destinations: newOrder.destinations,
                        extension: newOrder.extension,
                        __v: existsOrder["__v"] + 1
                    }
                );

                const orderUpdated = await this.findOrder(newOrder.id);
                console.log(JSON.stringify(orderUpdated));
                
                this.newVersion(orderUpdated, orderUpdated["__v"]);

                console.log("[updateOrder] Order updated: ", orderUpdated);

                this.notifyWebsockets();

                return orderUpdated;

            } catch (error) {
                console.log("[updateOrder] ", error);
                throw new Error(error);
            }
        } else {
            console.log("[orderUpdated] Order " + id + " not found.");
            throw new ConflictException('Order ' + id + ' not found.');
        }
    }

    async cancelOrder(id: string){
        const existsOrder = await this.findOrder(id);
        if (existsOrder){
            try {

                await existsOrder.updateOne(
                    {
                        id,
                        type: null,
                        insertedAt: null,
                        confirmAt: null,
                        finishAt: null,
                        trafficReadAt: null,
                        trafficStartedAt: null,
                        trafficFinishedAt: null,
                        agvId: null,
                        destinations: null
                    }
                );
                
                const orderUpdated = await this.findOrder(id);
            
                this.newVersion(orderUpdated, orderUpdated["__v"]);

                console.log("[cancelOrder] Order canceled: ", orderUpdated);

                this.notifyWebsockets();

                return orderUpdated;

            } catch (error) {
                console.log("[cancelOrder] ", error);
                throw new Error(error);
            }
        } else {
            console.log("[orderUpdated] Order " + id + " not found.");
            throw new ConflictException('Order ' + id + ' not found.');
        }
    }

    async finishOrder(id: string){
        const existsOrder = await this.findOrder(id);
        if (existsOrder){
            try {

                await existsOrder.updateOne(
                    {
                        finishAt: new Date(),
                    }
                );
                
                const orderUpdated = await this.findOrder(id);
            
                this.newVersion(orderUpdated, orderUpdated["__v"]);

                console.log("[finishOrder] Order finished: ", orderUpdated);

                await this.OrderFinishedModel.create({
                    id: orderUpdated.id,
                    type: orderUpdated.type,
                    description: orderUpdated.description,
                    insertedAt: orderUpdated.insertedAt,
                    confirmAt: orderUpdated.confirmAt,
                    finishAt: orderUpdated.finishAt,
                    trafficReadAt: orderUpdated.trafficReadAt,
                    trafficStartedAt: orderUpdated.trafficStartedAt,
                    trafficFinishedAt: orderUpdated.trafficFinishedAt,
                    manual: orderUpdated.manual,
                    agvId: orderUpdated.agvId,
                    priority: orderUpdated.priority,
                    origin: orderUpdated.origin._id,
                    destination: orderUpdated.destination._id,
                    destinations: orderUpdated.destinations,
                    extension: orderUpdated.extension
                });

                await this.deleteOrder(id);

                this.notifyWebsockets();

                return orderUpdated;

            } catch (error) {
                console.log("[finishOrder] ", error);
                throw new Error(error);
            }
        } else {
            console.log("[finishOrder] Order " + id + " not found.");
            throw new ConflictException('Order ' + id + ' not found.');
        }
    }

    async confirmOrder(id: string){
        const existsOrder = await this.findOrder(id);
        if (existsOrder){
            try {

                await existsOrder.updateOne(
                    {
                        confirmAt: new Date(),
                        __v: existsOrder["__v"] + 1
                    }
                );

                const orderUpdated = await this.findOrder(id);
                
                this.newVersion(orderUpdated, orderUpdated["__v"]);

                console.log("[confirmOrder] Order confirmed: ", orderUpdated);

                this.notifyWebsockets();

                return orderUpdated;

            } catch (error) {
                console.log("[confirmOrder] ", error);
                throw new Error(error);
            }
        } else {
            console.log("[orderUpdated] Order " + id + " not found.");
            throw new ConflictException('Order ' + id + ' not found.');
        }
    }

    async deleteOrder(id: string){

        try {
            const order = await this.OrderModel.findOne({ id });
            if (order) {
                order.delete();
                
                this.newVersion(order, -1);

                console.log('[deleteOrder] Order ' + id + ' deleted.');
                this.notifyWebsockets();
            } else {
                console.log('[deleteOrder] Order ' + id + ' not found.');
                throw new ConflictException('Order ' + id + ' not found.');
            }
            return order;
        } catch (error) {
           console.log("[deleteOrder] ", error);
           throw new Error(error);
        }
    }

    private async newVersion(order: IOrder, version: number){
   
        if(this.historic){

            const orderVersion = new this.OrderHistoricModel({
                id: order.id,
                type: order.type,
                insertedAt: order.insertedAt,
                confirmAt: order.confirmAt,
                finishAt: order.finishAt,
                trafficReadAt: order.trafficReadAt,
                trafficStartedAt: order.trafficStartedAt,
                trafficFinishedAt: order.trafficFinishedAt,
                manual: order.manual,
                agvId: order.agvId,
                priority: order.priority,
                origin: order.origin._id,
                destination: order.destination._id,
                destinations: order.destinations,
                extension: order.extension
            });
            await orderVersion.save();
            await orderVersion.updateOne(   
                {
                    __v: version
                }
            );

        }
    }

    async findOrder(id: string){
        const order = await this.OrderModel.findOne({ id });
        return order;
    }

    // WEBSOCKET: Notify change to all clients
    async notifyWebsockets(){

        try {
            let orders;
            orders = await this.getCurrentOrders();
            this.websocketService.sendMessageBroadcast(WS_CURRENT_ORDERS, orders);
            orders = await this.getPendingOrders();
            this.websocketService.sendMessageBroadcast(WS_PENDING_ORDERS, orders);
            orders = await this.getConfirmedOrders();
            this.websocketService.sendMessageBroadcast(WS_CONFIRMED_ORDERS, orders);
            if(this.finished){
                orders = await this.getFinishedOrders();
                this.websocketService.sendMessageBroadcast(WS_FINISHED_ORDERS, orders);    
            }
            if(this.historic){
                orders = await this.fetchHistoricOrders();
                this.websocketService.sendMessageBroadcast(WS_HISTORIC_ORDERS, orders);
            }
        } catch (err) {
            console.error('[Websocket] Emit error - buffer free');
            console.error(err);
        }

    }
}
