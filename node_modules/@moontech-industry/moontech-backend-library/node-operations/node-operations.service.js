"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeOperationsService = void 0;
const common_1 = require("@nestjs/common");
const node_opcua_client_1 = require("node-opcua-client");
const PlcVariable_1 = require("./models/PlcVariable");
const node_operations_constants_1 = require("./node-operations.constants");
let NodeOperationsService = class NodeOperationsService {
    constructor() { }
    async check_session(session) {
        return session != null;
    }
    async getMultiplePlcVariablesValueByNodeId(session, nodeId) {
        if (!(await this.check_session(session))) {
            console.log(`${node_operations_constants_1.INVALID_SESSION} ${session}`);
        }
        else {
            try {
                let res = await Promise.all(nodeId.map(async (element) => {
                    return await this.getPlcVariableValueByNodeId(session, element);
                }));
                return res.sort((a, b) => {
                    if (a.name > b.name) {
                        return 1;
                    }
                    if (a.name < b.name) {
                        return -1;
                    }
                    return 0;
                });
            }
            catch (error) {
                throw new common_1.ConflictException(`[Error] ${error}`);
            }
        }
    }
    async getPlcVariableValueByNodeId(session, nodeId) {
        if (!(await this.check_session(session))) {
            console.log('Invalid session');
        }
        else {
            try {
                const readValue = {
                    nodeId: nodeId,
                    attributeId: node_opcua_client_1.AttributeIds.Value,
                };
                const readName = {
                    nodeId: nodeId,
                    attributeId: node_opcua_client_1.AttributeIds.DisplayName,
                };
                const readDataType = {
                    nodeId: nodeId,
                    attributeId: node_opcua_client_1.AttributeIds.DataType,
                };
                const dataValue = await session.read([
                    readValue,
                    readName,
                    readDataType,
                ]);
                let parsedName = dataValue[1].value.value
                    .toString()
                    .match(/text=.*/)[0]
                    .split('=')[1]
                    .split(' ')[0];
                let parsedDataType = dataValue[2].value.value.value;
                return new PlcVariable_1.PlcVariable(parsedName, dataValue[0].value.value, node_opcua_client_1.DataType[parsedDataType]);
            }
            catch (error) {
                throw new common_1.NotFoundException(`[Error] This nodeId does not exist`);
            }
        }
    }
    async setPlcVariableValueByNodeId(session, nodeId, nodeValue) {
        if (!(await this.check_session(session))) {
            console.log('Invalid session');
        }
        else {
            try {
                const nodeIdClass = (0, node_opcua_client_1.coerceNodeId)(nodeId);
                const dataType = await session.getBuiltInDataType(nodeIdClass);
                const nodeToWrite = {
                    nodeId: nodeId,
                    attributeId: node_opcua_client_1.AttributeIds.Value,
                    value: {
                        value: {
                            dataType: dataType,
                            value: nodeValue,
                        },
                    },
                };
                const statusCode = await session.write(nodeToWrite);
                console.log(statusCode);
                return statusCode === node_opcua_client_1.StatusCodes.Good;
            }
            catch (error) {
                throw new common_1.ConflictException(`[Error] ${error}`);
            }
        }
    }
    async browseByNodeId(session, nodeId) {
        if (!(await this.check_session(session))) {
            console.log('Invalid session');
        }
        else {
            try {
                let browseResultObject = await session.browse({
                    nodeId,
                    nodeClassMask: node_opcua_client_1.NodeClass.Object,
                });
                let browseResultVariable = await session.browse({
                    nodeId,
                    nodeClassMask: node_opcua_client_1.NodeClass.Variable,
                });
                return {
                    variables: browseResultVariable.references.map((item) => {
                        return item.nodeId;
                    }),
                    objects: browseResultObject,
                };
            }
            catch (error) {
                throw new common_1.ConflictException(`[Error] ${error}`);
            }
        }
    }
};
NodeOperationsService = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [])
], NodeOperationsService);
exports.NodeOperationsService = NodeOperationsService;
//# sourceMappingURL=node-operations.service.js.map