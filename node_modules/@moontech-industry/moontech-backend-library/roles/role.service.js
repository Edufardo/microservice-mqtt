"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RoleService = void 0;
const common_1 = require("@nestjs/common");
const permission_dto_1 = require("../permissions/dto/permission.dto");
const role_model_1 = require("../models-mongo/role.model");
const mongo_db_service_1 = require("../mongo-db/mongo-db.service");
const permissions_service_1 = require("../permissions/permissions.service");
const websocket_gateway_1 = require("../websocket/websocket.gateway");
const websocketEvents_1 = require("../websocket/constants/websocketEvents");
const users_service_1 = require("../users/users.service");
let RoleService = class RoleService {
    constructor(mongoDb, permissionService, usersService, websocketService) {
        this.mongoDb = mongoDb;
        this.permissionService = permissionService;
        this.usersService = usersService;
        this.websocketService = websocketService;
        this.RoleModel = this.mongoDb
            .getConnection()
            .model("Role", role_model_1.roleSchema, "roles");
    }
    async populate() {
        const permissions = await this.permissionService.fetchAllPermissions();
        const roles = [
            {
                name: "superadmin",
                permissions: []
            },
            {
                name: "admin",
                permissions: [
                    new permission_dto_1.PermissionDto('CREATE'),
                    new permission_dto_1.PermissionDto('READ'),
                    new permission_dto_1.PermissionDto('UPDATE'),
                    new permission_dto_1.PermissionDto('DELETE'),
                ]
            },
            {
                name: "operator",
                permissions: [
                    new permission_dto_1.PermissionDto('CREATE'),
                    new permission_dto_1.PermissionDto('READ'),
                ]
            }
        ];
        for (const r of roles) {
            const role = await this.findRole(r.name);
            if (!role) {
                await this.createRole(r);
            }
        }
    }
    async getRoles() {
        try {
            const roles = await this.RoleModel.find({ name: { $ne: "superadmin" } }).populate('permissions');
            console.log("[getRoles] Roles: ", roles);
            return roles;
        }
        catch (error) {
            console.log("[getRoles] ", error);
            throw new Error(error);
        }
    }
    async createRole(role) {
        const roleExists = await this.findRole(role.name);
        if (roleExists) {
            console.log("[createRole] Role " + role.name + " already exists");
            throw new common_1.ConflictException(role.name + " already exists");
        }
        const newRole = new this.RoleModel({
            name: role.name,
            permissions: []
        });
        for (const p of role.permissions) {
            const permission = await this.permissionService.findPermission(p.permissionName);
            if (!permission) {
                console.log("[createRole] " + permission.permissionName + " not found");
                throw new common_1.ConflictException(permission.permissionName + " not found");
            }
            else {
                newRole.permissions.push(permission._id);
            }
        }
        try {
            await newRole.save();
            console.log("[createRole] New role created: ", newRole);
            this.notifyWebsockets();
            return newRole;
        }
        catch (error) {
            console.log("[createRole] ", error);
            throw new Error(error);
        }
    }
    async deleteRole(roleName) {
        try {
            const role = await this.RoleModel.findOne({ name: roleName });
            if (role) {
                const hasUsers = await this.usersService.roleHasUsers(role.name);
                if (hasUsers) {
                    console.log('[deleteRole] Role ' + roleName + ' has users.');
                    throw new common_1.ConflictException('Role ' + roleName + ' has users.');
                }
                role.delete();
                console.log('[deleteRole] Role ' + roleName + ' deleted.');
                this.notifyWebsockets();
            }
            else {
                console.log('[deleteRole] Role ' + roleName + ' not found.');
                throw new common_1.ConflictException('Role ' + roleName + ' not found.');
            }
            return role;
        }
        catch (error) {
            console.log("[deleteRole] ", error);
            throw new Error(error);
        }
    }
    async updateRole(oldRoleName, newRole) {
        const existsRole = await this.findRole(oldRoleName);
        if (existsRole) {
            try {
                for (const p of newRole.permissions) {
                    const permission = await this.permissionService.findPermission(p.permissionName);
                    if (!permission) {
                        console.log("[updateRole] " + permission.permissionName + " not found");
                        throw new common_1.ConflictException(permission.permissionName + " not found");
                    }
                }
                await existsRole.updateOne({
                    name: newRole.name,
                    permissions: newRole.permissions
                });
                const roleUpdated = await this.findRole(newRole.name);
                console.log("[updateRole] Role updated: ", roleUpdated);
                this.notifyWebsockets();
                return roleUpdated;
            }
            catch (error) {
                console.log("[updateRole] ", error);
                throw new Error(error);
            }
        }
        else {
            console.log("[updateRole] Role ' + oldRoleName + ' not found.");
            throw new common_1.ConflictException('Role ' + oldRoleName + ' not found.');
        }
    }
    async findRole(role) {
        try {
            const roleFound = await this.RoleModel.findOne({ name: role });
            return roleFound;
        }
        catch (error) {
            console.log("[findRole] ", error);
        }
        return null;
    }
    async notifyWebsockets() {
        try {
            let roles = await this.getRoles();
            this.websocketService.sendMessageBroadcast(websocketEvents_1.WS_ROLES, roles);
        }
        catch (err) {
            console.error('[Websocket] Emit error - buffer free');
            console.error(err);
        }
    }
};
RoleService = __decorate([
    (0, common_1.Injectable)(),
    __param(2, (0, common_1.Inject)((0, common_1.forwardRef)(() => users_service_1.UsersService))),
    __metadata("design:paramtypes", [mongo_db_service_1.MongoDbService,
        permissions_service_1.PermissionService,
        users_service_1.UsersService,
        websocket_gateway_1.WebsocketGateway])
], RoleService);
exports.RoleService = RoleService;
//# sourceMappingURL=role.service.js.map