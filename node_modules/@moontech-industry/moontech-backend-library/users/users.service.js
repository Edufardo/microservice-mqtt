"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UsersService = void 0;
const common_1 = require("@nestjs/common");
const user_model_1 = require("../models-mongo/user.model");
const mongo_db_service_1 = require("../mongo-db/mongo-db.service");
const permission_dto_1 = require("../permissions/dto/permission.dto");
const role_dto_1 = require("../roles/dto/role.dto");
const role_service_1 = require("../roles/role.service");
const websocketEvents_1 = require("../websocket/constants/websocketEvents");
const websocket_gateway_1 = require("../websocket/websocket.gateway");
let UsersService = class UsersService {
    constructor(mongoDb, roleService, websocketService) {
        this.mongoDb = mongoDb;
        this.roleService = roleService;
        this.websocketService = websocketService;
        this.UserModel = this.mongoDb
            .getConnection()
            .model('User', user_model_1.userSchema, 'users');
    }
    async populate() {
        const users = [
            {
                "userCode": "superadmin",
                "password": "123456789Abc!",
                "email": "superadmin@moontech.com",
                "role": new role_dto_1.RoleDto("superadmin", [])
            },
            {
                "userCode": "admin",
                "password": "123456789Abc!",
                "email": "admin@moontech.com",
                "role": new role_dto_1.RoleDto("admin", [
                    new permission_dto_1.PermissionDto("CREATE"),
                    new permission_dto_1.PermissionDto("READ"),
                    new permission_dto_1.PermissionDto("UPDATE"),
                    new permission_dto_1.PermissionDto("DELETE")
                ])
            }
        ];
        for (const u of users) {
            const user = await this.findUser(u.userCode);
            if (!user) {
                await this.createUser(u);
            }
        }
    }
    async createUser(newUser) {
        const user = await this.findUser(newUser.userCode);
        if (user) {
            console.log("[createUser] User already exists.");
            throw new common_1.ConflictException('User already exists.');
        }
        const roleExists = await this.roleService.findRole(newUser.role.name);
        if (!roleExists) {
            console.log("[createUser] Role does not exist.");
            throw new common_1.ConflictException('Role does not exist.');
        }
        try {
            const user = new this.UserModel({
                userCode: newUser.userCode,
                password: newUser.password,
                email: newUser.email,
                role: roleExists._id
            });
            await user.save();
            console.log("[createUser] New user created ", user);
            this.notifyWebsockets();
            user.password = undefined;
            return user;
        }
        catch (error) {
            console.log(error);
            if ((error.code = 11000)) {
                if (error.keyValue) {
                    for (const [key, value] of Object.entries(error === null || error === void 0 ? void 0 : error.keyValue)) {
                        throw new common_1.ConflictException("[createUser] " + key + ' already exists (' + value + ')');
                    }
                }
            }
            else {
                console.log("[createUser] ", error);
                throw new Error(error);
            }
        }
    }
    async deleteUser(userCode) {
        const user = await this.findUser(userCode);
        if (user) {
            await user.delete();
            console.log('[deleteUser] User ' + userCode + ' deleted.');
            this.notifyWebsockets();
            return user;
        }
        else {
            console.log('[deleteUser] User not found.');
            throw new common_1.ConflictException('User not found.');
        }
    }
    async updateUser(userCode, newUser) {
        const user = await this.findUser(userCode);
        if (user) {
            if (newUser.password) {
                let res = await user.comparePassword(newUser.password);
                if (!res) {
                    console.log('[updateUser] Incorrect password.');
                    throw new common_1.ConflictException('Incorrect password.');
                }
            }
            const roleExists = await this.roleService.findRole(newUser.role.name);
            if (!roleExists) {
                console.log("[updateUser] Role does not exist.");
                throw new common_1.ConflictException('Role does not exist.');
            }
            try {
                await user.updateOne({
                    userCode: newUser.userCode,
                    password: newUser.password,
                    email: newUser.email,
                    role: roleExists._id
                });
                console.log('[updateUser] User ' + userCode + ' updated.');
                this.notifyWebsockets();
                return user;
            }
            catch (error) {
                console.error("[updateUser] ", error);
                throw new Error(error);
            }
        }
        else {
            console.log('[updateUser] User not found');
            throw new common_1.ConflictException('User not found.');
        }
    }
    async findUser(userCode) {
        const user = await this.UserModel.findOne({ userCode: userCode.toLowerCase() });
        return user;
    }
    async fetchAllUsers() {
        try {
            let users = await this.UserModel.find({ userCode: { $ne: "superadmin" } }).populate('role');
            for (const u of users) {
                const role = await this.roleService.findRole(u.role.name);
                u.role = await role.populate('permissions').execPopulate();
            }
            users.forEach((user) => {
                user.password = undefined;
            });
            return users;
        }
        catch (error) {
            console.log(error);
        }
    }
    async roleHasUsers(name) {
        const users = await this.UserModel.aggregate([
            {
                $lookup: {
                    from: "roles",
                    localField: "role",
                    foreignField: "_id",
                    as: "role"
                },
            },
            {
                $match: {
                    "role.name": name
                }
            }
        ]);
        return users.length > 0;
    }
    async fetchUserData(userCode) {
        const user = await this.UserModel.findOne({ userCode }).populate('role');
        const role = await this.roleService.findRole(user.role.name);
        user.role = await role.populate('permissions').execPopulate();
        return user;
    }
    async notifyWebsockets() {
        try {
            let users = await this.fetchAllUsers();
            this.websocketService.sendMessageBroadcast(websocketEvents_1.WS_USERS, users);
        }
        catch (err) {
            console.error('[Websocket] Emit error - buffer free');
            console.error(err);
        }
    }
};
UsersService = __decorate([
    (0, common_1.Injectable)(),
    __param(1, (0, common_1.Inject)((0, common_1.forwardRef)(() => role_service_1.RoleService))),
    __metadata("design:paramtypes", [mongo_db_service_1.MongoDbService,
        role_service_1.RoleService,
        websocket_gateway_1.WebsocketGateway])
], UsersService);
exports.UsersService = UsersService;
//# sourceMappingURL=users.service.js.map